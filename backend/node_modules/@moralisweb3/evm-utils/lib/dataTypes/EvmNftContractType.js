"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeEvmNftContractType = exports.EvmNftContractType = void 0;
var core_1 = require("@moralisweb3/core");
var EvmNftContractType;
(function (EvmNftContractType) {
    EvmNftContractType["ERC721"] = "ERC721";
    EvmNftContractType["ERC1155"] = "ERC1155";
})(EvmNftContractType = exports.EvmNftContractType || (exports.EvmNftContractType = {}));
function normalizeEvmNftContractType(value) {
    switch (value.toUpperCase()) {
        case EvmNftContractType.ERC1155:
            return EvmNftContractType.ERC1155;
        case EvmNftContractType.ERC721:
            return EvmNftContractType.ERC721;
    }
    throw new core_1.MoralisCoreError({
        code: core_1.CoreErrorCode.INVALID_ARGUMENT,
        message: "Invalid NFT contract type provided: ".concat(value),
    });
}
exports.normalizeEvmNftContractType = normalizeEvmNftContractType;
//# sourceMappingURL=EvmNftContractType.js.map